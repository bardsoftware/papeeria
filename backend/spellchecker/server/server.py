# Author: Sergey Sokolov
import time
import argparse
from concurrent import futures

import grpc

from spellchecker import Spellchecker
import spellchecker_pb2


_ONE_DAY_IN_SECONDS = 60 * 60 * 24


class SpellcheckerServicer(spellchecker_pb2.SpellcheckServicer):
    """
    gRPC service to check text that comes from clients.
    """
    def __init__(self, libparser, dict_path):
        self.checker = Spellchecker(libparser, dict_path)

    def CheckText(self, request, context):
        """
        Method gets request from client that contains text to check and
        languages list and returns Suggestions message (JSON-like).

        :param request: Object generated by gRPC, contains text and languages inside.
        :param context: gRPC service object, never mind this one.
        :return: Suggestions message.
        """
        text = str(request.text, encoding="UTF-8")
        languages = [lang for lang in request.language]

        return self.checker.check_text(text, languages)


def serve(port: str, max_workers: int, libparser: str, dict_path: str):
    """
    Initialize and run the gRPC server.

    :param port: Port on which the server would be listening.
    :param max_workers: Size of thread pool to serve clients.
    :param libparser: Path to C parser shared library.
    :param dict_path: Path to .dic and .aff files
    """
    server = grpc.server(
        futures.ThreadPoolExecutor(max_workers=max_workers)
    )

    spellchecker_pb2.add_SpellcheckServicer_to_server(
        SpellcheckerServicer(libparser, dict_path),
        server
    )

    server.add_insecure_port("[::]:{}".format(port))
    server.start()

    try:
        while True:
            time.sleep(_ONE_DAY_IN_SECONDS)
    except KeyboardInterrupt:
        server.stop(0)

if __name__ == "__main__":
    args_parser = argparse.ArgumentParser(description="Spellchecker gRPC server.")
    args_parser.add_argument("-w", "--workers",
                             action="store",
                             type=int,
                             default=2,
                             metavar="NUM",
                             help="size of thread pool")

    required = args_parser.add_argument_group("required")
    required.add_argument("-p", "--port",
                          required=True,
                          action="store",
                          type=int,
                          metavar="NUM",
                          help="port which server would be listening")
    required.add_argument("-l", "--libparser",
                          required=True,
                          action="store",
                          type=str,
                          metavar="PATH",
                          help="path to libparser shared library")
    required.add_argument("-d", "--dir",
                          required=True,
                          action="store",
                          type=str,
                          metavar="PATH",
                          help="path to .dic and .aff files")

    args = args_parser.parse_args()

    serve(args.port, args.workers, args.libparser, args.dir)
